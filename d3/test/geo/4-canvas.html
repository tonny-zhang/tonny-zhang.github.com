<!DOCTYPE html>
<meta charset="utf-8">
<title>Geographic Viewport Clipping</title>
<style>
@import url(../maps.css);
canvas {
    cursor: move;
}

.hint {
    font-style: italic;
}
</style>
<p class="breadcrumbs"><a href="http://www.jasondavies.com/">Jason Davies</a> → <a href="../">Maps</a>
    <h1>Geographic Viewport Clipping</h1>
    <div id="map"></div>
    <p>
        <button id="pause">Pause</button>
        <div class="wrapper">
            <p>Viewport clipping of geographic features using <a href="http://d3js.org/">D3</a> version 3.1.
                <p class="hint">Hint: zoom by scrolling your mouse or pinching on a touch screen.
                    <p>You can specify an arbitrary 2D clip rectangle in pixel coordinates. The benefits are twofold:
                        <ol>
                            <li>Large pixel values are avoided, which can sometimes cause issues with browser rendering. This only occurs if the projection itself has areas of extreme distortion, e.g. the <a href="http://bl.ocks.org/mbostock/3790444">satellite projection</a>.
                                <li>Smaller SVG paths are generated, which should be rendered faster.
                        </ol>
                        <p>The <a href="http://en.wikipedia.org/wiki/Liang%E2%80%93Barsky_algorithm">Liang–Barsky algorithm</a> is used to clip lines efficiently against a rectangular viewport.
                            <p>For polygons, we rejoin these lines along the clip region edge using <a href="http://davis.wpi.edu/~matt/courses/clipping/">Greiner–Hormann</a>, which can clip arbitrary polygons (the same algorithm is used to <a href="../clip/">clip polygons on a sphere</a>).
        </div>
        <script src="../../d3.min.js"></script>
        <script src="../../topojson.min.js"></script>
        <script>
        var velocity = [.0010, -.0002],
            t0 = Date.now(),
            dragging = false,
            pause = false;

        var ratio = window.devicePixelRatio || 1,
            width = 960 * ratio,
            height = 550 * ratio;

        var dx = 2.5 * ratio;

        var projection = d3.geo.orthographic()
            .clipAngle(90)
            .translate([width / 2, height / 2])
            .scale(550 * ratio)
            .precision(1)
            // .clipExtent([
            //     [dx, dx],
            //     [width - dx, height - dx]
            // ])
            .rotate([40.7, -76.8])

        var graticule = d3.geo.graticule().step([5, 5]).extent([
            [-180, -85],
            [180, 85 + 1e-6]
        ])();

        var canvas = d3.select("#map").append("canvas")
            .attr("width", width)
            .attr("height", height)
            .style("width", width / ratio + "px")
            .style("height", height / ratio + "px")
            .call(d3.behavior.zoom()
                .scale(projection.scale())
                .scaleExtent([100 * ratio, Infinity])
                .on("zoom", function() {
                    projection.scale(d3.event.scale);
                    redraw();
                }))
            .call(d3.behavior.drag()
                .origin(function() {
                    var r = projection.rotate(),
                        s = .004 * projection.scale();
                    return {
                        x: s * r[0],
                        y: -s * r[1]
                    };
                })
                .on("drag", function() {
                    dragging = true;
                    var s = .004 * projection.scale();
                    projection.rotate(initial = [d3.event.x / s, -d3.event.y / s]);
                    redraw();
                })
                .on("dragend", function() {
                    dragging = false;
                    t0 = Date.now();
                }));

        d3.select("#pause").on("click", function() {
            d3.select(this).text((pause = !pause) ? "Play" : "Pause");
            t0 = Date.now();
        });

        var context = canvas.node().getContext("2d"),
            land;

        var path = d3.geo.path()
            .projection(projection)
            .context(context);

        d3.timer(function() {
            if (dragging || pause) return;
            var t = Date.now(),
                dt = t - t0,
                rotate = projection.rotate();
            t0 = t;
            rotate[0] += velocity[0] * dt;
            rotate[1] += velocity[1] * dt;
            projection.rotate(rotate);
            redraw();
        });

        d3.json("../../data/world-110m.json", function(error, world) {
            land = topojson.feature(world, world.objects.land);
            redraw();
        });

        function redraw() {
            context.clearRect(0, 0, width, height);

            context.lineWidth = .75 * ratio;
            context.strokeStyle = "#000";
            context.fillStyle = "#eee";
            context.beginPath(), path(land), context.fill(), context.stroke();

            context.lineWidth = .5 * ratio;
            context.strokeStyle = "#ccc";
            context.beginPath(), path(graticule), context.stroke();
        }
        </script>
